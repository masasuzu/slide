=========================================
カジュアルにターミナルを
=========================================

第二回DevLOVEターミナル勉強会



Version
:1.0 of 2012/03/26

Author
:SUZUKI Masashi / masasuzu

Mail
:m15.suzuki.masashi@gmail.com




Agenda
============================================
1. 自己紹介とか.
2. ターミナルを使う.
3. コードを書く.
4. ログを見る.





自己紹介とか
============================================
* すずきまさし (鈴木 勝史)
* 株式会社モバイルファクトリー システム開発部
* @masasuz





コンテキストとか
============================================

* 黒い画面でごにょごにょするお仕事は2年くらい
* 普段のお仕事は携帯の公式サイトとか携帯向けのソーシャルアプリとか開発
* 開発から運用保守まで大体全部やります
* vim / perl / mysql / tscreen / zsh



普段のお仕事環境
============================================

クライアントマシン
:Windows7

ターミナル
:mintty

開発マシン
:Debian Lenny

    Client PC
    (mintty on Windows)
        |
        |
        |  ssh    Development Machine
        +-------> (Debian Lenny on VM)
                    |
                    |  ssh    IDC
                    +-------> (Debian Lenny)









前回
============================================

第一回ターミナル勉強会で普段のターミナルの使い方について話をさせていただきました。

* http://masasuzu.github.com/slide/build/2011-09-12_devlove_terminal.html




今回
============================================

一歩進めてカジュアルな感じで、もうちょっとターミナルを便利に使うために覚えると便利かもしれないコマンドの使い方を.zsh_historyから適当に拾ってきて紹介します。

濃いお話はきっと ようぞうさんや 緒方さんにしていただけると思いますのでカジュアルな感じで行きます。

基本、debian lennyで確認しています。macとかだと動かないかも。

ターミナルを使う
============================================


コマンドライン編集
============================================

コマンドラインはデフォルトで、emacsキーバインドになっています。
emacsキーバインドを覚えておくと効率よくコマンドラインを編集することができるようになります。

set -oで変更することができます。

    set -o vi
    set -o emacs

emacsキーバインド
============================================

* Ctrl + f
  * 右に移動  →
  * forward
* Ctrl + b
  * 左に移動  ←
  * back
* Ctrl + h
  * 1文字削除、バックスペース
* Ctrl + j
  * Enter
* Ctrl + [
  * ESC



emacsキーバインド cont.
============================================

* ESC + f
  * 右に1単語移動
* ESC + b
  * 左に1単語移動
* ESC + d
  * 右の1単語削除
* Ctrl + w
  * 左の1単語削除


emacsキーバインド cont..
============================================

* Ctrl + a
  * 行頭に移動
  * 一番最初のa
* Ctrl + e
  * 行末に移動
  * end
* Ctrl + k
  * 現在位置から行末まで削除


ヒストリー
============================================

* Ctrl + p
  * コマンド履歴の後方参照
  * previous
* Ctrl + n
  * コマンド履歴の前方参照
  * next
* Ctrl + r
  * コマンド履歴の後方検索
* Ctrl + s
  * コマンド履歴の前方検索


fc
============================================

コマンドラインをエディタで編集できます。EDITOR変数に指定されているエディタが立ち上がります。


コードを書く
============================================








vim
============================================








vim -c
============================================

普段エディタはvimを使っています。-cオプションを付けると起動時にコマンドを実行してくれます。

    vim -c ":NERDTree"




vim -d
============================================

diffを使っても良いんですが、vimでシンタックスハイライトをしてくれるので、ハイライト大好きな人なら使っておいて損は無いかと。

また、vimで開いているのでその場で編集できます。

    vim -d  ${FILE1} ${FILE2}
    vimdiff ${FILE1} ${FILE2}

vim -b -c ':%!xxd'
============================================

バイナリも開けるよ。
使ったことはほぼないですが。。。


    vim -b -c ':%!xxd' ${FILE}


vim -R
============================================

読み込み専用モードで開く。シンタックスハイライトが(ry

※ 本番サーバではlessとかlv使ってね。

    vim -R ${FILE}
    view   ${FILE}

コードを探す
============================================








grep
============================================

grep -r
============================================

再帰的に検索してくれます。

    grep -r          ${PATTERN} ./
    grep --recursive ${PATTERN} ./
    grep -d recurse  ${PATTERN} ./
    grep --directories=recurse ${PATTERN} ./







grep -n
============================================

行数を表示します。

    grep -rn ${PATTERN} ./

grep -A -B -C
============================================

"-A n"でマッチした行の後ろの行n行、"-B n"でマッチした行の前n行も表示してくれます。
"-C n"で前後n行を表示します。

メソッドとかの使用コンテキストを知りたい時に使うと便利。

    grep -r -A3 -B3 ${PATTERN} ./
    grep -r -C3     ${PATTERN} ./


grep --exclude-dir
============================================

除外ディレクトリを指定できます。.gitとか.svmとかを除外しておくと良いです。

    grep -r --exclude-dir=".git" ${PATTERN} ./




grep --color
============================================

検索結果を色づけしてくれます。

    grep -r --color=auto --exclude-dir=.git ${PATTERN} ./



grep -v
============================================

マッチしない行を返してくれます。
検索の絞り込みとかに使うと便利ですね。

    grep -r ${PATTERN1} ./ | grep -v ${PATTERN2}




grep -w -x
============================================

"-w"オプションは単語としてマッチした行、"-x"オプションは行としてマッチした行を返してくれます。

"-w"オプションは変数名とかメソッド名を探す時に使えるかな。

    grep -r  -w            ${PATTERN} ./
    grep -r  --word-regexp ${PATTERN} ./

    grep -r  -x            ${PATTERN} ./
    grep -r  --line-regexp ${PATTERN} ./

grep -h
============================================

ファイル名を表示させません。パイプラインに喰わせる時に使います。




grep -c
============================================

ファイル毎でマッチした回数をカウントします。

    grep -rc ${PATTERN} ./

awkとかに喰わせれば、プロジェクト内でメソッドが合計でどれくらい使われているかとか測ったりもできます。

    grep -rwhc ${PATTERN} ./ | awk 'BEGIN{sum=0}{sum=sum+$1}END{print sum}'
    grep -rwhc ${PATTERN} ./ | perl -E 'my $c; while (<STDIN>) { chomp; $c += $_; }; say $c'


grep -c cont.
============================================

そんな面倒なことしなくても、wc -lに喰わせれば良いのでした。

    grep -rw ${PATTERN} ./ | wc -l

grep -l -L
============================================

"-l"オプションでマッチしたファイル名を表示、"-L"オプションでマッチしなかったファイル名を表示します。

    grep -rwl                     ${PATTERN} ./
    grep -rw --files-with-matches ${PATTERN} ./

    grep -rwL                      ${PATTERN} ./
    grep -rw --files-without-match ${PATTERN} ./

    grep -rwl ${PATTERN} ./ | wc -l

grepその他
============================================

* --binary-files=without-match
  * バイナリファイルを無視してくれます。
* -q --quiet --silent
  * ステータスコードだけ返す。シェルスクリプトとかで使うと良いかも。
* -i --ignore-case
  * 大文字小文字を区別しません。
* SEE ALSO
  * LANG=C man grep


GREP_OPTIONS変数
============================================

GREP_OPTIONS変数を定義しておくと、grep使用時に指定されたオプションを付けてくれます。

"--recursive"とか"--color"あたりを.zshrcとかに入れておくと良いでしょう。

    GREP_OPTIONS="--recursive --color=auto --exclude-dir=.git"



ack
============================================

Perlで実装されたgrep互換のコマンド。
cpanだとApp::Ack、debianだとack-grepってパッケージ名になっているはず。

デフォルトで、色づけされていたり、再帰的に検索してくれるので、カジュアルに使うにはgrepよりは便利。



git grep
============================================

gitを使っているなら素直にgit grep使った方が良いシーンが多いと思います。
grep本体より低機能。





ログを見る
============================================

date
============================================

現在時刻を表示するコマンド。フォーマットを指定することもできるので、日にちでローテションしているログファイルにアクセスするのに使えます。

    tail -f /usr/local/apache/logs/$( date +"%Y/%m/error.%Y_%m%d").log
    # tail -f /usr/local/apache/logs/2012/03/error.2012_0326.log

こういうのは毎回打つのが面倒なので、パスの通ったところに実行権を付けてスクリプトファイルにしておくと再利用できて便利です。

    tail -f $(apache_error_log)

tail
============================================

tailfをgrepに喰わせることで、フィルタリングすることもできます。

    tail -f /var/log/any.log | fgrep error

sedで特定の単語をansii colorで色づけしてあげることもできます。

    tail -f /var/log/any.log | sed -e 's/\([error]\)/\x1b[33m\1\x1b[0m/g'

ssh
============================================

ssh接続先に一番最後の引数にコマンドを指定すると接続先にコマンドを実行することがでいます。

こんな感じで、リモートサーバのエラーログを見ることができます。

    ssh 192.168.1.2 "tail -100 /var/log/any.log | fgrep [error]"


最後に
============================================

拙い発表ですが、明日からの現場に役立つことが1つでもあれば幸いです。

私自身ターミナルの達人には遠いと思っているので、これ違うよとかもっと便利な方法があるよとかありましたら、次回のターミナル勉強会で是非発表していただけるとありがたいです。

求む。達人ターミナル使い。


Thank you.
============================================

