=========================================
黒い画面入門 Part.II
=========================================


Version
:1.0 of 2012/06/04

Author
:SUZUKI Masashi / masasuzu

Mail
:m15.suzuki.masashi@gmail.com




Agenda
============================================

1. zshことはじめ
2. 設定ファイル
3. パイプとリダイレクト
4. aliasとfunction
5. 開発で使うと便利かも知れないコマンド



前提条件
============================================

基本的に以下の環境で動かすことを前提にしています。

* Debian lenny
* vim
* zsh
* screen( or tscreen )


1. zshことはじめ
============================================

そもそもシェルとは
--------------------

ユーザからの指示を解釈し、プログラムの起動や制御を行うプログラムです。
windowsのGUIならexplorerなどもそうです。CUIであれば、コマンドプロンプトなど。

ターミナルはシェルでは無く、あくまで端末であり、その端末を通して入力されたコマンドラインを解釈し、プログラムを実行するのがシェルです。


Unixのシェル
------------------------

Unix系のシェルは以下のものがあります。

* Bourne Shell(sh)
* Korn Shell(ksh)
* Bourne Agen Shell(bash)
  * Linuxの標準シェル
* Z Shell(zsh)
* Almquist Shell(ash)
* Debian Almquist Shell(dash)
  * Debianの/bin/shはコレ

* C Shell(csh)
* TENEX C Shell(tcsh)

zshは何者
------------------------------

shを基本とした高機能なシェル。bashより便利なシェルと今は覚えておけば問題ないです。
当社ではユーザのデフォルトのシェルをコレに設定しています。

    man -L C zsh

ちょっと便利なzsh
------------------------------

コマンドラインスタック
------------------------------

コマンドラインを途中まで打った後、Ctrl + qを押すとコマンドラインをスタックすることができる。
コマンド実行後に自動的にコマンドラインにポップされます。

オートヘルプ
------------------------------

コマンドを打った後、ESC + hを押すとman pageを表示させることができます。

コマンドを途中まで打った後引数とか調べたい時に便利。

コマンド補完
------------------------------

コマンドを途中まで打った後、TabまたはCtrl + i でコマンドの補完ができます。
また、ESC + Ctrl + dで候補一覧を出力することができます。

コマンド補完を有効にするには下記の設定を入れておく必要があります。

    autoload -U compinit && compinit

また、新しいコマンドを入れた際にはrehashを実行することで補完の候補を更新することができます。

2. 設定ファイル
============================================

zshの設定ファイルは各種あり、場合によって読み込まれるもの読み込まれないものがあるので、読み込み順とともに軽く覚えておくと良いでしょう。

* SEE ALSO
  * http://d.hatena.ne.jp/masasuz/20120506/1336286016

各種ファイル
-----------------------------------

* ~/.zshenv
  * 常に読み込まれるファイルなのでパス等常用するものを書いておくと良いでしょう
* ~/.zprofile
  * ちょっと使いどころが分かってない。すみません。
* ~/.zshrc
  * インタラクティブシェルとして使うときに読み込まれます。プロンプトなどの設定を書いておくと良いでしょう。
* ~/.zlogin
  * ログイン時に読み込まれます
* ~/.zlogout
  * ログアウト時に読み込まれます

ログインシェルでzshを起動した時
-----------------------------------

1. ~/.zshenv
2. ~/.zprofile
3. ~/.zshrc
4. ~/.zlogin

インタラクティブシェルでzshを起動した時
-----------------------------------

1. ~/.zshenv
2. ~/.zshrc

シェルスクリプトとしてzshを起動した時
-----------------------------------

1. ~/.zshenv

ログアウトする時
-----------------------------------

1. ~/.zlogout




3. パイプラインとリダイレクション
============================================

あるコマンドの標準出力をあるコマンドの標準入力に渡すのをパイプライン。

ファイルの中身を標準入力としてコマンドを実行、またはコマンドの標準出力をファイルに向けて書き出すのをリダイレクションと言います。

その前に標準入出力のはなし
-----------------------------------

Unixにおいて標準入力はキーボードの入力。標準出力はディスプレイへの出力です。出力にはもう一つ標準エラー出力があります。

標準出力がバッファリングされるのに対し、標準エラー出力はバッファリングされずに即座に出力されます。

デフォルトの入出力先を変える仕組みがパイプラインやリダイレクションと言うことです。

パイプラインに使うコマンド
-----------------------------------


sort
-----------------------------------

ファイルをソートするコマンド。

    sort <filename>

    du -h ./* | sort -n

grep, egrep, fgrep
-----------------------------------

パターンにマッチする行を表示する。

    grep 'pattern' <filename>

    ps -ef | egrep '[m]ysql'

lv
-----------------------------------

ファイルをページングして表示するコマンド。

    lv <filename>

    ps -ef | egrep '[m]ysql' | lv


wc
-----------------------------------

ファイル内のバイト数、行数、単語数を数える

    wc <filename>

    ps -ef | egrep '[m]ysql' | wc -l  #行数のみ出力


リダイレクション
-----------------------------------

標準入力からのリダイレクトは "<"

標準出力への上書きリダイレクトは ">"

標準出力への追記リダイレクトは ">>"

    ls > ls.txt
    sort < ls.txt

/dev/null
-----------------------------------

リダイレクト先を/dev/nullに指定することで出力を捨てることが出来ます。

    ls > /dev/null

標準エラー出力のリダイレクト
-----------------------------------

標準出力のディスクリプタは1、標準エラー出力のディスクリプタは2になってます。

    cmd 1> file1
    cmd > file1

    cmd 2> file2
    cmd 1> /dev/null 2> file2

標準エラー出力と標準出力を同じファイルにリダイレクトする場合。

    cmd > file 2>&1

tee
-----------------------------------

teeコマンドを使うとファイルに標準出力を保存しつつ、ディスプレイでも出力が確認できます。

    cmd | tee cmd.log

4. aliasとfunction
============================================

よく使うオプションなどはaliasやfunctionとして設定ファイルに定義しておくと楽です。

    alias emacs='vim'
    alias ls='ls --color=auto'

    function errorlog() {
        if [ -d ${HOME}/var/log/apache ]
        then
            tail -f ${HOME}/var/log/apache/`date +%Y`/`date +%m`/error.`date +%Y_%m%d`.log
        else
            sudo tail -f /var/log/apache2/error.log
        fi
    }

5. 開発で使うと便利かも知れないコマンド
============================================

コードを書く
============================================








vim
============================================








vim -c
============================================

普段エディタはvimを使っています。-cオプションを付けると起動時にコマンドを実行してくれます。

    vim -c ":NERDTree"




vim -d
============================================

diffを使っても良いんですが、vimでシンタックスハイライトをしてくれるので、ハイライト大好きな人なら使っておいて損は無いかと。

また、vimで開いているのでその場で編集できます。

    vim -d  ${FILE1} ${FILE2}
    vimdiff ${FILE1} ${FILE2}

vim -b -c ':%!xxd'
============================================

バイナリも開けるよ。
使ったことはほぼないですが。。。


    vim -b -c ':%!xxd' ${FILE}


vim -R
============================================

読み込み専用モードで開く。シンタックスハイライトが(ry

※ 本番サーバではlessとかlv使ってね。

    vim -R ${FILE}
    view   ${FILE}

コードを探す
============================================








grep
============================================

grep -r
============================================

再帰的に検索してくれます。

    grep -r          ${PATTERN} ./
    grep --recursive ${PATTERN} ./
    grep -d recurse  ${PATTERN} ./
    grep --directories=recurse ${PATTERN} ./







grep -n
============================================

行数を表示します。

    grep -rn ${PATTERN} ./

grep -A -B -C
============================================

"-A n"でマッチした行の後ろの行n行、"-B n"でマッチした行の前n行も表示してくれます。
"-C n"で前後n行を表示します。

メソッドとかの使用コンテキストを知りたい時に使うと便利。

    grep -r -A3 -B3 ${PATTERN} ./
    grep -r -C3     ${PATTERN} ./


grep --exclude-dir
============================================

除外ディレクトリを指定できます。.gitとか.svmとかを除外しておくと良いです。

    grep -r --exclude-dir=".git" ${PATTERN} ./




grep --color
============================================

検索結果を色づけしてくれます。

    grep -r --color=auto --exclude-dir=.git ${PATTERN} ./



grep -v
============================================

マッチしない行を返してくれます。
検索の絞り込みとかに使うと便利ですね。

    grep -r ${PATTERN1} ./ | grep -v ${PATTERN2}




grep -w -x
============================================

"-w"オプションは単語としてマッチした行、"-x"オプションは行としてマッチした行を返してくれます。

"-w"オプションは変数名とかメソッド名を探す時に使えるかな。

    grep -r  -w            ${PATTERN} ./
    grep -r  --word-regexp ${PATTERN} ./

    grep -r  -x            ${PATTERN} ./
    grep -r  --line-regexp ${PATTERN} ./

grep -h
============================================

ファイル名を表示させません。パイプラインに喰わせる時に使います。




grep -c
============================================

ファイル毎でマッチした回数をカウントします。

    grep -rc ${PATTERN} ./

awkとかに喰わせれば、プロジェクト内でメソッドが合計でどれくらい使われているかとか測ったりもできます。

    grep -rwhc ${PATTERN} ./ | awk 'BEGIN{sum=0}{sum=sum+$1}END{print sum}'
    grep -rwhc ${PATTERN} ./ | perl -E 'my $c; while (<STDIN>) { chomp; $c += $_; }; say $c'


grep -c cont.
============================================

そんな面倒なことしなくても、wc -lに喰わせれば良いのでした。

    grep -rw ${PATTERN} ./ | wc -l

grep -l -L
============================================

"-l"オプションでマッチしたファイル名を表示、"-L"オプションでマッチしなかったファイル名を表示します。

    grep -rwl                     ${PATTERN} ./
    grep -rw --files-with-matches ${PATTERN} ./

    grep -rwL                      ${PATTERN} ./
    grep -rw --files-without-match ${PATTERN} ./

    grep -rwl ${PATTERN} ./ | wc -l

grepその他
============================================

* --binary-files=without-match
  * バイナリファイルを無視してくれます。
* -q --quiet --silent
  * ステータスコードだけ返す。シェルスクリプトとかで使うと良いかも。
* -i --ignore-case
  * 大文字小文字を区別しません。
* SEE ALSO
  * LANG=C man grep


GREP_OPTIONS変数
============================================

GREP_OPTIONS変数を定義しておくと、grep使用時に指定されたオプションを付けてくれます。

"--recursive"とか"--color"あたりを.zshrcとかに入れておくと良いでしょう。

    GREP_OPTIONS="--recursive --color=auto --exclude-dir=.git"



ack
============================================

Perlで実装されたgrep互換のコマンド。
cpanだとApp::Ack、debianだとack-grepってパッケージ名になっているはず。

デフォルトで、色づけされていたり、再帰的に検索してくれるので、カジュアルに使うにはgrepよりは便利。



git grep
============================================

gitを使っているなら素直にgit grep使った方が良いシーンが多いと思います。
grep本体より低機能。





ログを見る
============================================

date
============================================

現在時刻を表示するコマンド。フォーマットを指定することもできるので、日にちでローテションしているログファイルにアクセスするのに使えます。

    tail -f /usr/local/apache/logs/$( date +"%Y/%m/error.%Y_%m%d").log
    # tail -f /usr/local/apache/logs/2012/03/error.2012_0326.log

こういうのは毎回打つのが面倒なので、パスの通ったところに実行権を付けてスクリプトファイルにしておくと再利用できて便利です。

    tail -f $(apache_error_log)

tail
============================================

tailfをgrepに喰わせることで、フィルタリングすることもできます。

    tail -f /var/log/any.log | fgrep error

sedで特定の単語をansii colorで色づけしてあげることもできます。

    tail -f /var/log/any.log | sed -e 's/\([error]\)/\x1b[33m\1\x1b[0m/g'

ssh
============================================

ssh接続先に一番最後の引数にコマンドを指定すると接続先にコマンドを実行することがでいます。

こんな感じで、リモートサーバのエラーログを見ることができます。

    ssh 192.168.1.2 "tail -100 /var/log/any.log | fgrep [error]"


Thank you.
============================================

