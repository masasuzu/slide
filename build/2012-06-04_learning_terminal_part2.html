<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>黒い画面入門 Part II</title>
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" />
    <link href="css/impress.css" rel="stylesheet" />
</head>
<body>
<div id="impress" class="impress-not-supported">
    <div class="fallback-message">
        <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
        <p>For the best experience please use the latest <b>Chrome</b> or <b>Safari</b> browser. Firefox 10 (to be released soon) will also handle it.</p>
    </div>

<div id="title" class="step" data-y="0" data-x="0">
<h1>黒い画面入門 Part.II</h1>

<p>Version
:1.0 of 2012/06/04</p>

<p>Author
:SUZUKI Masashi / masasuzu</p>

<p>Mail
:m15.suzuki.masashi@gmail.com</p>

</div>
<div class="step" data-y="0" data-x="1200">
<h1>Agenda</h1>

<ol>
<li>zshことはじめ</li>
<li>設定ファイル</li>
<li>パイプとリダイレクト</li>
<li>aliasとfunction</li>
<li>開発で使うと便利かも知れないコマンド</li>
</ol>

</div>
<div class="step" data-y="0" data-x="2400">
<h1>前提条件</h1>

<p>基本的に以下の環境で動かすことを前提にしています。</p>

<ul>
<li>Debian lenny</li>
<li>vim</li>
<li>zsh</li>
<li>screen( or tscreen )</li>
</ul>

</div>
<div class="step" data-y="0" data-x="3600">
<h1>1. zshことはじめ</h1>

</div>
<div class="step" data-y="0" data-x="4800">
<h2>そもそもシェルとは</h2>

<p>ユーザからの指示を解釈し、プログラムの起動や制御を行うプログラムです。
windowsのGUIならexplorerなどもそうです。CUIであれば、コマンドプロンプトなど。</p>

<p>ターミナルはシェルでは無く、あくまで端末であり、その端末を通して入力されたコマンドラインを解釈し、プログラムを実行するのがシェルです。</p>

</div>
<div class="step" data-y="800" data-x="0">
<h2>Unixのシェル</h2>

<p>Unix系のシェルは以下のものがあります。</p>

<ul>
<li>Bourne Shell(sh)</li>
<li>Korn Shell(ksh)</li>
<li>Bourne Agen Shell(bash)
<ul>
<li>Linuxの標準シェル</li>
</ul></li>
<li>Z Shell(zsh)</li>
<li>Almquist Shell(ash)</li>
<li><p>Debian Almquist Shell(dash)</p>

<ul>
<li>Debianの/bin/shはコレ</li>
</ul></li>
<li><p>C Shell(csh)</p></li>
<li>TENEX C Shell(tcsh)</li>
</ul>

</div>
<div class="step" data-y="800" data-x="1200">
<h2>zshは何者</h2>

<p>shを基本とした高機能なシェル。bashより便利なシェルと今は覚えておけば問題ないです。
当社ではユーザのデフォルトのシェルをコレに設定しています。</p>

<pre><code>man -L C zsh
</code></pre>

</div>
<div class="step" data-y="800" data-x="2400">
<h2>ちょっと便利なzsh</h2>

</div>
<div class="step" data-y="800" data-x="3600">
<h2>コマンドラインスタック</h2>

<p>コマンドラインを途中まで打った後、Ctrl + qを押すとコマンドラインをスタックすることができる。
コマンド実行後に自動的にコマンドラインにポップされます。</p>

</div>
<div class="step" data-y="800" data-x="4800">
<h2>オートヘルプ</h2>

<p>コマンドを打った後、ESC + hを押すとman pageを表示させることができます。</p>

<p>コマンドを途中まで打った後引数とか調べたい時に便利。</p>

</div>
<div class="step" data-y="1600" data-x="0">
<h2>コマンド補完</h2>

<p>コマンドを途中まで打った後、TabまたはCtrl + i でコマンドの補完ができます。
また、ESC + Ctrl + dで候補一覧を出力することができます。</p>

<p>コマンド補完を有効にするには下記の設定を入れておく必要があります。</p>

<pre><code>autoload -U compinit &amp;&amp; compinit
</code></pre>

<p>また、新しいコマンドを入れた際にはrehashを実行することで補完の候補を更新することができます。</p>

</div>
<div class="step" data-y="1600" data-x="1200">
<h1>2. 設定ファイル</h1>

<p>zshの設定ファイルは各種あり、場合によって読み込まれるもの読み込まれないものがあるので、読み込み順とともに軽く覚えておくと良いでしょう。</p>

<ul>
<li>SEE ALSO
<ul>
<li>http://d.hatena.ne.jp/masasuz/20120506/1336286016</li>
</ul></li>
</ul>

</div>
<div class="step" data-y="1600" data-x="2400">
<h2>各種ファイル</h2>

<ul>
<li>~/.zshenv
<ul>
<li>常に読み込まれるファイルなのでパス等常用するものを書いておくと良いでしょう</li>
</ul></li>
<li>~/.zprofile
<ul>
<li>ちょっと使いどころが分かってない。すみません。</li>
</ul></li>
<li>~/.zshrc
<ul>
<li>インタラクティブシェルとして使うときに読み込まれます。プロンプトなどの設定を書いておくと良いでしょう。</li>
</ul></li>
<li>~/.zlogin
<ul>
<li>ログイン時に読み込まれます</li>
</ul></li>
<li>~/.zlogout
<ul>
<li>ログアウト時に読み込まれます</li>
</ul></li>
</ul>

</div>
<div class="step" data-y="1600" data-x="3600">
<h2>ログインシェルでzshを起動した時</h2>

<ol>
<li>~/.zshenv</li>
<li>~/.zprofile</li>
<li>~/.zshrc</li>
<li>~/.zlogin</li>
</ol>

</div>
<div class="step" data-y="1600" data-x="4800">
<h2>インタラクティブシェルでzshを起動した時</h2>

<ol>
<li>~/.zshenv</li>
<li>~/.zshrc</li>
</ol>

</div>
<div class="step" data-y="2400" data-x="0">
<h2>シェルスクリプトとしてzshを起動した時</h2>

<ol>
<li>~/.zshenv</li>
</ol>

</div>
<div class="step" data-y="2400" data-x="1200">
<h2>ログアウトする時</h2>

<ol>
<li>~/.zlogout</li>
</ol>

</div>
<div class="step" data-y="2400" data-x="2400">
<h1>3. パイプラインとリダイレクション</h1>

<p>あるコマンドの標準出力をあるコマンドの標準入力に渡すのをパイプライン。</p>

<p>ファイルの中身を標準入力としてコマンドを実行、またはコマンドの標準出力をファイルに向けて書き出すのをリダイレクションと言います。</p>

</div>
<div class="step" data-y="2400" data-x="3600">
<h2>その前に標準入出力のはなし</h2>

<p>Unixにおいて標準入力はキーボードの入力。標準出力はディスプレイへの出力です。出力にはもう一つ標準エラー出力があります。</p>

<p>標準出力がバッファリングされるのに対し、標準エラー出力はバッファリングされずに即座に出力されます。</p>

<p>デフォルトの入出力先を変える仕組みがパイプラインやリダイレクションと言うことです。</p>

</div>
<div class="step" data-y="2400" data-x="4800">
<h2>パイプラインに使うコマンド</h2>

</div>
<div class="step" data-y="3200" data-x="0">
<h2>sort</h2>

<p>ファイルをソートするコマンド。</p>

<pre><code>sort &lt;filename&gt;

du -h ./* | sort -n
</code></pre>

</div>
<div class="step" data-y="3200" data-x="1200">
<h2>grep, egrep, fgrep</h2>

<p>パターンにマッチする行を表示する。</p>

<pre><code>grep 'pattern' &lt;filename&gt;

ps -ef | egrep '[m]ysql'
</code></pre>

</div>
<div class="step" data-y="3200" data-x="2400">
<h2>lv</h2>

<p>ファイルをページングして表示するコマンド。</p>

<pre><code>lv &lt;filename&gt;

ps -ef | egrep '[m]ysql' | lv
</code></pre>

</div>
<div class="step" data-y="3200" data-x="3600">
<h2>wc</h2>

<p>ファイル内のバイト数、行数、単語数を数える</p>

<pre><code>wc &lt;filename&gt;

ps -ef | egrep '[m]ysql' | wc -l  #行数のみ出力
</code></pre>

</div>
<div class="step" data-y="3200" data-x="4800">
<h2>リダイレクション</h2>

<p>標準入力からのリダイレクトは "&lt;"</p>

<p>標準出力への上書きリダイレクトは ">"</p>

<p>標準出力への追記リダイレクトは ">>"</p>

<pre><code>ls &gt; ls.txt
sort &lt; ls.txt
</code></pre>

</div>
<div class="step" data-y="4000" data-x="0">
<h2>/dev/null</h2>

<p>リダイレクト先を/dev/nullに指定することで出力を捨てることが出来ます。</p>

<pre><code>ls &gt; /dev/null
</code></pre>

</div>
<div class="step" data-y="4000" data-x="1200">
<h2>標準エラー出力のリダイレクト</h2>

<p>標準出力のディスクリプタは1、標準エラー出力のディスクリプタは2になってます。</p>

<pre><code>cmd 1&gt; file1
cmd &gt; file1

cmd 2&gt; file2
cmd 1&gt; /dev/null 2&gt; file2
</code></pre>

<p>標準エラー出力と標準出力を同じファイルにリダイレクトする場合。</p>

<pre><code>cmd &gt; file 2&gt;&amp;1
</code></pre>

</div>
<div class="step" data-y="4000" data-x="2400">
<h2>tee</h2>

<p>teeコマンドを使うとファイルに標準出力を保存しつつ、ディスプレイでも出力が確認できます。</p>

<pre><code>cmd | tee cmd.log
</code></pre>

</div>
<div class="step" data-y="4000" data-x="3600">
<h1>4. aliasとfunction</h1>

<p>よく使うオプションなどはaliasやfunctionとして設定ファイルに定義しておくと楽です。</p>

<pre><code>alias emacs='vim'
alias ls='ls --color=auto'

function errorlog() {
    if [ -d ${HOME}/var/log/apache ]
    then
        tail -f ${HOME}/var/log/apache/`date +%Y`/`date +%m`/error.`date +%Y_%m%d`.log
    else
        sudo tail -f /var/log/apache2/error.log
    fi
}
</code></pre>

</div>
<div class="step" data-y="4000" data-x="4800">
<h1>5. 開発で使うと便利かも知れないコマンド</h1>

</div>
<div class="step" data-y="4800" data-x="0">
<h1>コードを書く</h1>

</div>
<div class="step" data-y="4800" data-x="1200">
<h1>vim</h1>

</div>
<div class="step" data-y="4800" data-x="2400">
<h1>vim -c</h1>

<p>普段エディタはvimを使っています。-cオプションを付けると起動時にコマンドを実行してくれます。</p>

<pre><code>vim -c ":NERDTree"
</code></pre>

</div>
<div class="step" data-y="4800" data-x="3600">
<h1>vim -d</h1>

<p>diffを使っても良いんですが、vimでシンタックスハイライトをしてくれるので、ハイライト大好きな人なら使っておいて損は無いかと。</p>

<p>また、vimで開いているのでその場で編集できます。</p>

<pre><code>vim -d  ${FILE1} ${FILE2}
vimdiff ${FILE1} ${FILE2}
</code></pre>

</div>
<div class="step" data-y="4800" data-x="4800">
<h1>vim -b -c ':%!xxd'</h1>

<p>バイナリも開けるよ。
使ったことはほぼないですが。。。</p>

<pre><code>vim -b -c ':%!xxd' ${FILE}
</code></pre>

</div>
<div class="step" data-y="5600" data-x="0">
<h1>vim -R</h1>

<p>読み込み専用モードで開く。シンタックスハイライトが(ry</p>

<p>※ 本番サーバではlessとかlv使ってね。</p>

<pre><code>vim -R ${FILE}
view   ${FILE}
</code></pre>

</div>
<div class="step" data-y="5600" data-x="1200">
<h1>コードを探す</h1>

</div>
<div class="step" data-y="5600" data-x="2400">
<h1>grep</h1>

</div>
<div class="step" data-y="5600" data-x="3600">
<h1>grep -r</h1>

<p>再帰的に検索してくれます。</p>

<pre><code>grep -r          ${PATTERN} ./
grep --recursive ${PATTERN} ./
grep -d recurse  ${PATTERN} ./
grep --directories=recurse ${PATTERN} ./
</code></pre>

</div>
<div class="step" data-y="5600" data-x="4800">
<h1>grep -n</h1>

<p>行数を表示します。</p>

<pre><code>grep -rn ${PATTERN} ./
</code></pre>

</div>
<div class="step" data-y="6400" data-x="0">
<h1>grep -A -B -C</h1>

<p>"-A n"でマッチした行の後ろの行n行、"-B n"でマッチした行の前n行も表示してくれます。
"-C n"で前後n行を表示します。</p>

<p>メソッドとかの使用コンテキストを知りたい時に使うと便利。</p>

<pre><code>grep -r -A3 -B3 ${PATTERN} ./
grep -r -C3     ${PATTERN} ./
</code></pre>

</div>
<div class="step" data-y="6400" data-x="1200">
<h1>grep --exclude-dir</h1>

<p>除外ディレクトリを指定できます。.gitとか.svmとかを除外しておくと良いです。</p>

<pre><code>grep -r --exclude-dir=".git" ${PATTERN} ./
</code></pre>

</div>
<div class="step" data-y="6400" data-x="2400">
<h1>grep --color</h1>

<p>検索結果を色づけしてくれます。</p>

<pre><code>grep -r --color=auto --exclude-dir=.git ${PATTERN} ./
</code></pre>

</div>
<div class="step" data-y="6400" data-x="3600">
<h1>grep -v</h1>

<p>マッチしない行を返してくれます。
検索の絞り込みとかに使うと便利ですね。</p>

<pre><code>grep -r ${PATTERN1} ./ | grep -v ${PATTERN2}
</code></pre>

</div>
<div class="step" data-y="6400" data-x="4800">
<h1>grep -w -x</h1>

<p>"-w"オプションは単語としてマッチした行、"-x"オプションは行としてマッチした行を返してくれます。</p>

<p>"-w"オプションは変数名とかメソッド名を探す時に使えるかな。</p>

<pre><code>grep -r  -w            ${PATTERN} ./
grep -r  --word-regexp ${PATTERN} ./

grep -r  -x            ${PATTERN} ./
grep -r  --line-regexp ${PATTERN} ./
</code></pre>

</div>
<div class="step" data-y="7200" data-x="0">
<h1>grep -h</h1>

<p>ファイル名を表示させません。パイプラインに喰わせる時に使います。</p>

</div>
<div class="step" data-y="7200" data-x="1200">
<h1>grep -c</h1>

<p>ファイル毎でマッチした回数をカウントします。</p>

<pre><code>grep -rc ${PATTERN} ./
</code></pre>

<p>awkとかに喰わせれば、プロジェクト内でメソッドが合計でどれくらい使われているかとか測ったりもできます。</p>

<pre><code>grep -rwhc ${PATTERN} ./ | awk 'BEGIN{sum=0}{sum=sum+$1}END{print sum}'
grep -rwhc ${PATTERN} ./ | perl -E 'my $c; while (&lt;STDIN&gt;) { chomp; $c += $_; }; say $c'
</code></pre>

</div>
<div class="step" data-y="7200" data-x="2400">
<h1>grep -c cont.</h1>

<p>そんな面倒なことしなくても、wc -lに喰わせれば良いのでした。</p>

<pre><code>grep -rw ${PATTERN} ./ | wc -l
</code></pre>

</div>
<div class="step" data-y="7200" data-x="3600">
<h1>grep -l -L</h1>

<p>"-l"オプションでマッチしたファイル名を表示、"-L"オプションでマッチしなかったファイル名を表示します。</p>

<pre><code>grep -rwl                     ${PATTERN} ./
grep -rw --files-with-matches ${PATTERN} ./

grep -rwL                      ${PATTERN} ./
grep -rw --files-without-match ${PATTERN} ./

grep -rwl ${PATTERN} ./ | wc -l
</code></pre>

</div>
<div class="step" data-y="7200" data-x="4800">
<h1>grepその他</h1>

<ul>
<li>--binary-files=without-match
<ul>
<li>バイナリファイルを無視してくれます。</li>
</ul></li>
<li>-q --quiet --silent
<ul>
<li>ステータスコードだけ返す。シェルスクリプトとかで使うと良いかも。</li>
</ul></li>
<li>-i --ignore-case
<ul>
<li>大文字小文字を区別しません。</li>
</ul></li>
<li>SEE ALSO
<ul>
<li>LANG=C man grep</li>
</ul></li>
</ul>

</div>
<div class="step" data-y="8000" data-x="0">
<h1>GREP_OPTIONS変数</h1>

<p>GREP_OPTIONS変数を定義しておくと、grep使用時に指定されたオプションを付けてくれます。</p>

<p>"--recursive"とか"--color"あたりを.zshrcとかに入れておくと良いでしょう。</p>

<pre><code>GREP_OPTIONS="--recursive --color=auto --exclude-dir=.git"
</code></pre>

</div>
<div class="step" data-y="8000" data-x="1200">
<h1>ack</h1>

<p>Perlで実装されたgrep互換のコマンド。
cpanだとApp::Ack、debianだとack-grepってパッケージ名になっているはず。</p>

<p>デフォルトで、色づけされていたり、再帰的に検索してくれるので、カジュアルに使うにはgrepよりは便利。</p>

</div>
<div class="step" data-y="8000" data-x="2400">
<h1>git grep</h1>

<p>gitを使っているなら素直にgit grep使った方が良いシーンが多いと思います。
grep本体より低機能。</p>

</div>
<div class="step" data-y="8000" data-x="3600">
<h1>ログを見る</h1>

</div>
<div class="step" data-y="8000" data-x="4800">
<h1>date</h1>

<p>現在時刻を表示するコマンド。フォーマットを指定することもできるので、日にちでローテションしているログファイルにアクセスするのに使えます。</p>

<pre><code>tail -f /usr/local/apache/logs/$( date +"%Y/%m/error.%Y_%m%d").log
# tail -f /usr/local/apache/logs/2012/03/error.2012_0326.log
</code></pre>

<p>こういうのは毎回打つのが面倒なので、パスの通ったところに実行権を付けてスクリプトファイルにしておくと再利用できて便利です。</p>

<pre><code>tail -f $(apache_error_log)
</code></pre>

</div>
<div class="step" data-y="8800" data-x="0">
<h1>tail</h1>

<p>tailfをgrepに喰わせることで、フィルタリングすることもできます。</p>

<pre><code>tail -f /var/log/any.log | fgrep error
</code></pre>

<p>sedで特定の単語をansii colorで色づけしてあげることもできます。</p>

<pre><code>tail -f /var/log/any.log | sed -e 's/\([error]\)/\x1b[33m\1\x1b[0m/g'
</code></pre>

</div>
<div class="step" data-y="8800" data-x="1200">
<h1>ssh</h1>

<p>ssh接続先に一番最後の引数にコマンドを指定すると接続先にコマンドを実行することがでいます。</p>

<p>こんな感じで、リモートサーバのエラーログを見ることができます。</p>

<pre><code>ssh 192.168.1.2 "tail -100 /var/log/any.log | fgrep [error]"
</code></pre>

</div>
<div class="step" data-y="8800" data-x="2400">
<h1>Thank you.</h1>

</div>


    <div id="overview" class="step" data-x="3000" data-y="1500" data-scale="10">
    </div>

</div>

<div class="hint">
    <p>Use a spacebar or arrow keys to navigate</p>
</div>
<script>
if ("ontouchstart" in document.documentElement) { 
    document.querySelector(".hint").innerHTML = "<p>Tap on the left or right to navigate</p>";
}
</script>
<script src="js/impress.js"></script>

</body>
</html>

